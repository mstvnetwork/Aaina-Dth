<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>MSTV LIVE</title>
<style>
    :root { --accent: #ff0000; }
    body, html { 
        margin: 0; padding: 0; width: 100%; height: 100%; 
        background: #000; overflow: hidden; font-family: sans-serif; 
    }

    /* Fullscreen Player Container */
    #player-wrap { 
        position: relative; width: 100vw; height: 100vh; 
        display: flex; align-items: center; justify-content: center; 
    }
    
    video { width: 100%; height: 100%; object-fit: contain; outline: none; }

    /* Channel Logo Overlay */
    .brand { 
        position: absolute; top: 30px; right: 30px; 
        display: flex; flex-direction: column; align-items: flex-end; 
        pointer-events: none; opacity: 0.8; z-index: 10;
    }
    .brand-name { color: white; font-weight: 900; font-size: 24px; letter-spacing: 1px; }
    .live-tag { background: var(--accent); color: white; font-size: 12px; padding: 2px 6px; font-weight: bold; border-radius: 2px; }

    /* Clean Overlay for loading */
    #status-overlay {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.7); display: flex; flex-direction: column;
        align-items: center; justify-content: center; z-index: 20;
        visibility: hidden; transition: 0.3s;
    }
    #status-overlay.active { visibility: visible; }
    .spinner {
        width: 50px; height: 50px; border: 5px solid rgba(255,255,255,0.1);
        border-top: 5px solid var(--accent); border-radius: 50%;
        animation: spin 1s linear infinite; margin-bottom: 15px;
    }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    /* TV-Style Minimal Controls */
    #ui-layer {
        position: absolute; bottom: 30px; right: 30px;
        display: flex; gap: 15px; opacity: 0; transition: 0.5s; z-index: 30;
    }
    #player-wrap:hover #ui-layer { opacity: 1; }
    .ctrl-btn {
        background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.3);
        color: white; width: 50px; height: 50px; border-radius: 50%;
        cursor: pointer; display: flex; align-items: center; justify-content: center;
        font-size: 20px; backdrop-filter: blur(5px);
    }
</style>
</head>
<body>

<div id="player-wrap">
    <!-- Branding -->
    <div class="brand">
        <div class="brand-name">MSTV</div>
        <div class="live-tag">LIVE</div>
    </div>

    <!-- Loading State -->
    <div id="status-overlay">
        <div class="spinner"></div>
        <div style="color: white; font-size: 14px; letter-spacing: 1px;">LOADING STREAM... PLEASE STAY ON</div>
    </div>

    <video id="main-video" playsinline muted autoplay></video>

    <!-- UI Buttons -->
    <div id="ui-layer">
        <button class="ctrl-btn" id="mute-toggle">ðŸ”‡</button>
        <button class="ctrl-btn" id="fs-toggle">â›¶</button>
    </div>
</div>

<script>
const video = document.getElementById('main-video');
const statusOverlay = document.getElementById('status-overlay');
const muteBtn = document.getElementById('mute-toggle');
const fsBtn = document.getElementById('fs-toggle');

let currentVideoUrl = "";
let isInitialLoad = true;

async function syncPseudoLive() {
    try {
        // Fetch fresh JSON every time to handle playlist updates mid-stream
        const response = await fetch('./playlist.json?nocache=' + Date.now());
        const data = await response.json();
        
        // Use the first channel by default
        const ch = data.channels[0];
        const totalDuration = ch.playlist.reduce((acc, item) => acc + item.duration, 0);
        
        const startTime = new Date(ch.start_iso).getTime();
        const elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
        const playheadPos = elapsedSeconds % totalDuration;

        let accumulatedTime = 0;
        let activeItem = ch.playlist[0];

        for (const item of ch.playlist) {
            if (playheadPos < (accumulatedTime + item.duration)) {
                activeItem = item;
                break;
            }
            accumulatedTime += item.duration;
        }

        const seekTime = playheadPos - accumulatedTime;

        // Only change src if the video file has actually changed
        if (currentVideoUrl !== activeItem.url) {
            currentVideoUrl = activeItem.url;
            showLoading(true);
            video.src = activeItem.url;
            video.load();
            video.onloadedmetadata = () => {
                video.currentTime = seekTime;
                video.play().catch(() => { /* Handle autoplay block */ });
                showLoading(false);
            };
        } else {
            // Optional: Correct sync drift if more than 2 seconds off
            if (Math.abs(video.currentTime - seekTime) > 2) {
                video.currentTime = seekTime;
            }
        }
    } catch (err) {
        console.error("Sync Error:", err);
    }
}

function showLoading(state) {
    statusOverlay.classList.toggle('active', state);
}

// Interaction Listeners
muteBtn.onclick = () => {
    video.muted = !video.muted;
    muteBtn.innerText = video.muted ? "ðŸ”‡" : "ðŸ”Š";
};

fsBtn.onclick = () => {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
    } else {
        document.exitFullscreen();
    }
};

// Auto-sync every 10 seconds to check for playlist updates
setInterval(syncPseudoLive, 10000);
syncPseudoLive();

// Show loading if browser stalls
video.onwaiting = () => showLoading(true);
video.onplaying = () => showLoading(false);

</script>
</body>
</html>
